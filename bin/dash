#!/usr/bin/env ruby
#begin # XXX: Remove this begin/rescue before distributing your app
require 'dash'
#require 'ruby-debug';debugger

if ARGV.length==1 && ARGV[0].index(' ')   # fix for intellij
	parts = ARGV[0].split(' ')
	ARGV[0] = parts.shift
	ARGV.insert(-1,*parts)
end
#rescue LoadError
#  STDERR.puts "In development, you need to use `bundle exec bin/todo` to run your app"
#  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
#  STDERR.puts "Feel free to remove this message from bin/dash now"
#  exit 64
#end

HighLine::Question.class_eval do
	alias_method :orig_append_default, :append_default
	def append_default
		orig_append_default
		@question = StringUtils.split3(@question,/\|.*\|/) do |head,match,tail|
			match.sub!('|','(')
			match[match.rindex('|'),1]=')'
			match
		end
	end
end


include GLI::App

program_desc 'Describe your application here'

#version Dash::VERSION

#desc 'Describe some switch here'
#switch [:s,:switch]
#
#desc 'Describe some flag here'
#default_value 'the default'
#arg_name 'The name of the argument'
#flag [:f,:flagname]

desc 'configure credentials etc'
arg_name 'subcommands are: bitbucket'
command :configure do |configure|

	configure.desc 'configure bitbucket for managing repositories'
	configure.arg_name 'none'
	configure.command :bitbucket do |bb|
		bb.action do |global_options,options,args|
			context = Dash::Context.new(args)
			repo = Dash::Repo.new
			keyChain = Dash::KeyChain.new
			core = Dash::Core.new(
				:context => context,
			  :keyChain => keyChain,
			  :repo => repo
			)
			# use highline to ask questions here and store in key_chain
			username = ask("User name: ") { |q|
				q.default = "none"
			}
			say username
		end
	end
end


desc 'Describe push here'
arg_name 'Describe arguments to push here'
command :push do |c|
  c.desc 'Describe a switch to push'
  c.switch :s

  c.desc 'Describe a flag to push'
  c.default_value 'default'
  c.flag :f
  c.action do |global_options,options,args|

    # Your command logic here

    # If you have any errors, just raise them
    # raise "that command made no sense"

    puts "push command ran"
  end
end

desc 'Describe pull here'
arg_name 'Describe arguments to pull here'
command :pull do |c|
  c.action do |global_options,options,args|
    puts "pull command ran"
  end
end


desc 'Describe commit here'
arg_name 'Describe arguments to commit here'
command :commit do |c|
  c.action do |*args|
	  context = Dash::Context.new(args)
	  dash = Dash::Core.new(context)
	  dash.ensure_repo_open.commit
  end
end

desc 'Describe build here'
arg_name 'Describe arguments to build here'
command :build do |c|
  c.action do |global_options,options,args|
	  response = POpen4::shell('middleman build')
	  puts result[:stdout]
  end
end


#desc 'List tasks'
#long_desc <<EOS
#List the tasks in your task list, possibly including completed tasks.  By default, this will list
#all uncompleted tasks.
#EOS
#command [:list,:ls] do |c|
#
#	c.desc 'List all tasks, including completed ones'
#	c.command :all do |all|
#		all.action do
#			say 'list all'
#		end
#	end
#
#	c.default_command :all
#end

# download existing repo : dash clone git://somegitrepo
# server side repo clone : dash fork

# dash git ...    # talk directly to git
# dash middleman  # talk directly to middleman


# dash pull git://somegitrepo   # if no local repo, will ask "Do you wish to a) clone somegitrepo into a new folder /asds/dsa/somegitrepo or b) pull changes, except that you aren't inside a repo and haven't specified one"
# dash fork git://somegitrepo


#desc 'Describe clone here'
#arg_name 'Describe arguments to clone here'
#command :clone do |c|
#  c.action do |global_options,options,args|
#    puts "clone command ran"
#  end
#end
#
#pre do |global,command,options,args|
#  # Pre logic here
#  # Return true to proceed; false to abourt and not call the
#  # chosen command
#  # Use skips_pre before a command to skip this block
#  # on that command only
#  true
#end
#
#post do |global,command,options,args|
#  # Post logic here
#  # Use skips_post before a command to skip this
#  # block on that command only
#end
#
#on_error do |exception|
#  # Error logic here
#  # return false to skip default error handling
#  true
#end

exit run(ARGV)
